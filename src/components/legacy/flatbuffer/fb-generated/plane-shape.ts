// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers'

export class PlaneShape {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): PlaneShape {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsPlaneShape(
    bb: flatbuffers.ByteBuffer,
    obj?: PlaneShape
  ): PlaneShape {
    return (obj || new PlaneShape()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsPlaneShape(
    bb: flatbuffers.ByteBuffer,
    obj?: PlaneShape
  ): PlaneShape {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new PlaneShape()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  isPointerBlocker(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false
  }

  visible(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 8)
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false
  }

  uvs(index: number): number | null {
    const offset = this.bb!.__offset(this.bb_pos, 10)
    return offset
      ? this.bb!.readFloat32(
          this.bb!.__vector(this.bb_pos + offset) + index * 4
        )
      : 0
  }

  uvsLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 10)
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0
  }

  uvsArray(): Float32Array | null {
    const offset = this.bb!.__offset(this.bb_pos, 10)
    return offset
      ? new Float32Array(
          this.bb!.bytes().buffer,
          this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
          this.bb!.__vector_len(this.bb_pos + offset)
        )
      : null
  }

  width(): number {
    const offset = this.bb!.__offset(this.bb_pos, 12)
    return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0
  }

  height(): number {
    const offset = this.bb!.__offset(this.bb_pos, 14)
    return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0
  }

  static startPlaneShape(builder: flatbuffers.Builder) {
    builder.startObject(6)
  }

  static addIsPointerBlocker(
    builder: flatbuffers.Builder,
    isPointerBlocker: boolean
  ) {
    builder.addFieldInt8(1, +isPointerBlocker, +false)
  }

  static addVisible(builder: flatbuffers.Builder, visible: boolean) {
    builder.addFieldInt8(2, +visible, +false)
  }

  static addUvs(builder: flatbuffers.Builder, uvsOffset: flatbuffers.Offset) {
    builder.addFieldOffset(3, uvsOffset, 0)
  }

  static createUvsVector(
    builder: flatbuffers.Builder,
    data: number[] | Float32Array
  ): flatbuffers.Offset
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createUvsVector(
    builder: flatbuffers.Builder,
    data: number[] | Uint8Array
  ): flatbuffers.Offset
  static createUvsVector(
    builder: flatbuffers.Builder,
    data: number[] | Float32Array | Uint8Array
  ): flatbuffers.Offset {
    builder.startVector(4, data.length, 4)
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]!)
    }
    return builder.endVector()
  }

  static startUvsVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4)
  }

  static addWidth(builder: flatbuffers.Builder, width: number) {
    builder.addFieldFloat32(4, width, 0.0)
  }

  static addHeight(builder: flatbuffers.Builder, height: number) {
    builder.addFieldFloat32(5, height, 0.0)
  }

  static endPlaneShape(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static finishPlaneShapeBuffer(
    builder: flatbuffers.Builder,
    offset: flatbuffers.Offset
  ) {
    builder.finish(offset)
  }

  static finishSizePrefixedPlaneShapeBuffer(
    builder: flatbuffers.Builder,
    offset: flatbuffers.Offset
  ) {
    builder.finish(offset, undefined, true)
  }

  static createPlaneShape(
    builder: flatbuffers.Builder,
    isPointerBlocker: boolean,
    visible: boolean,
    uvsOffset: flatbuffers.Offset,
    width: number,
    height: number
  ): flatbuffers.Offset {
    PlaneShape.startPlaneShape(builder)
    PlaneShape.addIsPointerBlocker(builder, isPointerBlocker)
    PlaneShape.addVisible(builder, visible)
    PlaneShape.addUvs(builder, uvsOffset)
    PlaneShape.addWidth(builder, width)
    PlaneShape.addHeight(builder, height)
    return PlaneShape.endPlaneShape(builder)
  }

  unpack(): PlaneShapeT {
    return new PlaneShapeT(
      this.isPointerBlocker(),
      this.visible(),
      this.bb!.createScalarList(this.uvs.bind(this), this.uvsLength()),
      this.width(),
      this.height()
    )
  }

  unpackTo(_o: PlaneShapeT): void {
    _o.isPointerBlocker = this.isPointerBlocker()
    _o.visible = this.visible()
    _o.uvs = this.bb!.createScalarList(this.uvs.bind(this), this.uvsLength())
    _o.width = this.width()
    _o.height = this.height()
  }
}

export class PlaneShapeT {
  constructor(
    public isPointerBlocker: boolean = false,
    public visible: boolean = false,
    public uvs: number[] = [],
    public width: number = 0.0,
    public height: number = 0.0
  ) {}

  static pack(
    builder: flatbuffers.Builder,
    value: PlaneShapeT
  ): flatbuffers.Offset {
    const uvs = PlaneShape.createUvsVector(builder, value.uvs)

    return PlaneShape.createPlaneShape(
      builder,
      value.isPointerBlocker,
      value.visible,
      uvs,
      value.width,
      value.height
    )
  }
}
