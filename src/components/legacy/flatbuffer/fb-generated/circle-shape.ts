// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers'

export class CircleShape {
  bb: flatbuffers.ByteBuffer | null = null
  bb_pos = 0
  __init(i: number, bb: flatbuffers.ByteBuffer): CircleShape {
    this.bb_pos = i
    this.bb = bb
    return this
  }

  static getRootAsCircleShape(
    bb: flatbuffers.ByteBuffer,
    obj?: CircleShape
  ): CircleShape {
    return (obj || new CircleShape()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  static getSizePrefixedRootAsCircleShape(
    bb: flatbuffers.ByteBuffer,
    obj?: CircleShape
  ): CircleShape {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH)
    return (obj || new CircleShape()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    )
  }

  withCollisions(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 4)
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false
  }

  isPointerBlocker(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 6)
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false
  }

  visible(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 8)
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false
  }

  segments(): number {
    const offset = this.bb!.__offset(this.bb_pos, 10)
    return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0
  }

  arc(): number {
    const offset = this.bb!.__offset(this.bb_pos, 12)
    return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0
  }

  static startCircleShape(builder: flatbuffers.Builder) {
    builder.startObject(5)
  }

  static addWithCollisions(
    builder: flatbuffers.Builder,
    withCollisions: boolean
  ) {
    builder.addFieldInt8(0, +withCollisions, +false)
  }

  static addIsPointerBlocker(
    builder: flatbuffers.Builder,
    isPointerBlocker: boolean
  ) {
    builder.addFieldInt8(1, +isPointerBlocker, +false)
  }

  static addVisible(builder: flatbuffers.Builder, visible: boolean) {
    builder.addFieldInt8(2, +visible, +false)
  }

  static addSegments(builder: flatbuffers.Builder, segments: number) {
    builder.addFieldFloat32(3, segments, 0.0)
  }

  static addArc(builder: flatbuffers.Builder, arc: number) {
    builder.addFieldFloat32(4, arc, 0.0)
  }

  static endCircleShape(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject()
    return offset
  }

  static finishCircleShapeBuffer(
    builder: flatbuffers.Builder,
    offset: flatbuffers.Offset
  ) {
    builder.finish(offset)
  }

  static finishSizePrefixedCircleShapeBuffer(
    builder: flatbuffers.Builder,
    offset: flatbuffers.Offset
  ) {
    builder.finish(offset, undefined, true)
  }

  static createCircleShape(
    builder: flatbuffers.Builder,
    withCollisions: boolean,
    isPointerBlocker: boolean,
    visible: boolean,
    segments: number,
    arc: number
  ): flatbuffers.Offset {
    CircleShape.startCircleShape(builder)
    CircleShape.addWithCollisions(builder, withCollisions)
    CircleShape.addIsPointerBlocker(builder, isPointerBlocker)
    CircleShape.addVisible(builder, visible)
    CircleShape.addSegments(builder, segments)
    CircleShape.addArc(builder, arc)
    return CircleShape.endCircleShape(builder)
  }

  unpack(): CircleShapeT {
    return new CircleShapeT(
      this.withCollisions(),
      this.isPointerBlocker(),
      this.visible(),
      this.segments(),
      this.arc()
    )
  }

  unpackTo(_o: CircleShapeT): void {
    _o.withCollisions = this.withCollisions()
    _o.isPointerBlocker = this.isPointerBlocker()
    _o.visible = this.visible()
    _o.segments = this.segments()
    _o.arc = this.arc()
  }
}

export class CircleShapeT {
  constructor(
    public withCollisions: boolean = false,
    public isPointerBlocker: boolean = false,
    public visible: boolean = false,
    public segments: number = 0.0,
    public arc: number = 0.0
  ) {}

  static pack(
    builder: flatbuffers.Builder,
    value: CircleShapeT
  ): flatbuffers.Offset {
    return CircleShape.createCircleShape(
      builder,
      value.withCollisions,
      value.isPointerBlocker,
      value.visible,
      value.segments,
      value.arc
    )
  }
}
